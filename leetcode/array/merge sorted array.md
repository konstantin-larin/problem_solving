---
tags:
  - problem
level: easy
---

Дата: 2025-06-02
```simple-time-tracker
{"entries":[{"name":"Segment 1","startTime":"2025-06-02T15:41:52.924Z","endTime":"2025-06-02T16:41:45.604Z"}]}
```
# Ссылка: 
https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150

# Понимание условия
![[merge sorted array 2025-06-02 18.52.29.excalidraw]]
# Подход
- Что первым приходит в голову?
- Есть какие-то шаблоны?
- Есть ли возможность декомпозиции на частные случаи или на более простые задачи?
- Достаточно ли знаний алгоритмов и структур данных, чтобы решить эту задачу? Если нет - изучаем, если да - можно запускать таймер

1. Двигаемся по двум массивам справа налево
   Указатель на первом массиве стоит на позиции m, на втором - на n.
   Идея - во втором массиве должны быть наибольшие числа.

Логика цикла:
1. Если в первом массиве число больше, чем у второго, то меняем их. Понижаем указатель второго массива, при этом ставим наибольшее число (которое в массиве находится по текущему указателю) на позицию "первый указатель плюс второй" в первый.
2.  Если во втором массиве число больше, чем у первого, то понижаем первый указатель, при этом всегда меняем его с нулем, который ВСЕГДА СТОИТ СПРАВА ОТ НЕГО. Тем самым, указатель никогда не будет показывать ноль, но всегда будет гарантировать, что указывает на число, заменив которое по условию 1 мы получим возрастающий массив
3. Если числа в первом и втором массиве равны, то ставим число из второго массива в по индексу "первый указатель + 1", то есть вместо нуля.

# Код
```python
class Solution():
	
```
# Ревью

В целом идея пришла правильная - нужно идти справа налево. Но вот как ставить наибольшее - действительно, надо просто было еще один указатель поставить в конец массива. В общем, не додумал решение, но идея ясна - проходит m + n итераций, пока не кончатся все числа из массива 2, каждую итерацию декрементируем индекс по которому ставим наибольшее число.

```python
        midx = m - 1

        nidx = n - 1

        r = m + n - 1

        while nidx >= 0:

            if midx >= 0 and nums1[midx] > nums2[nidx]:

                nums1[r] = nums1[midx]

                midx -= 1              

            else:

                nums1[r] = nums2[nidx]

                nidx -= 1

            r -= 1
```
