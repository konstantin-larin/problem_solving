---
tags:
  - problem
level: medium
---

Дата: [[18-06-2025]]

# Ссылка: 
https://leetcode.com/problems/triangle/?envType=study-plan-v2&envId=top-interview-150

# Понимание условия
 - Ограничения по времени/памяти
 - Диапазоны входных данных
 - Разбери все случаи, включая крайние, которые будет решать код

# Подход
- Что первым приходит в голову?
- Есть какие-то шаблоны?
- Есть ли возможность декомпозиции на частные случаи или на более простые задачи?
- Достаточно ли знаний алгоритмов и структур данных, чтобы решить эту задачу? Если нет - изучаем, если да - можно запускать таймер

 Сразу пришла идея просто итеративно брать два числа по i и i+1 и смотреть какое из них меньше и идти туда. Звучит жадно, но неправильно. 
 Почему то на ум приходит представить треугольник как граф и  алгоритм дейкстры.
![[Triangle 2025-06-19 13.57.39.excalidraw]]
Вершина - каждый элемент (по индексу (row, col)).
Цель - попасть из вершины (0, 0) в вершины (конечная строка, любая колонка) по минимальному пути (определить по дейкстре)

```python
[
[2], 
[3,4],
[6,5,7],
[4,1,8,3]
]

graph = {
	(0, 0): {
		(1, 0): 3,
		(1, 1): 4,
	},
	(1, 0): {
		(2, 0): 6,
		(2, 1): 5,
	},
	(1, 1): {
		(2, 1): 5,
		(2, 2): 7,
	}
	
}
```


# Код
```python
from collections import defaultdict

import heapq

  

class Solution(object):

    def minimumTotal(self, triangle):

        """

        :type triangle: List[List[int]]

        :rtype: int

        """

  

        # составим граф

        graph = defaultdict(tuple)

        n = len(triangle)

        for i in range(n):            

            for j in range(0, i+1):

                graph[(i, j)] = defaultdict(tuple)

                if i < n - 1:

                    graph[(i, j)][(i + 1, j)] = triangle[i + 1][j]

                    graph[(i, j)][(i + 1, j + 1)] = triangle[i + 1][j + 1]

        # print(dict(graph))

        # нас интересует найти кратчайшие пути из (0, 0) к вершинам начинающимся c n - 1        

        # таких вершин n: (n - 1, 0), (n - 1, 1), (n - 1, 2) ... (n - 1, n - 1)

        # и выбрать минимальный из них

        # поэтому с помощью алгоритма Дейкстры найдем минимальные расстояния от вершины (0, 0) до всех остальных

        start_node =  (0, 0)

        distances = {node: float('inf') for node in graph}

        distances[start_node] = triangle[0][0]

        priority_queue = [(triangle[0][0], start_node)]        

  

        while priority_queue:

            current_distance, current_node = heapq.heappop(priority_queue)

            if current_distance > distances[current_node]:

                continue

            for neighbor, weight in graph[current_node].items():

                distance = current_distance + weight

  

                if distance < distances[neighbor]:

                    distances[neighbor] = distance

                    heapq.heappush(priority_queue, (distance, neighbor))        

  

        # после нахождения кратчайших путей ко всем вершинам ищем минимальный кратчайший путь до вершин лежащих на дне треугольника

        min_path = float('inf')        

        for i in range(n):

            v = (n - 1, i) # в вершина, к которой будем искать путь            

            if min_path > distances[v]:

                min_path = distances[v]

        return min_path
```
# Ревью

У меня получилось неоптимальное решение. Вот лучше:

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        row = len(triangle)
        # 1. Инициализация: Создаем массив memo, который изначально является копией последней строки треугольника.
        # Этот массив будет хранить минимальные суммы путей до каждой ячейки текущей обрабатываемой строки.
        memo = triangle[row-1].copy()

        # 2. Итерация снизу вверх:
        # Начинаем с предпоследней строки (row-2) и идем до самой верхней строки (0).
        for r in range(row - 2, -1, -1):
            # Для каждой ячейки (c) в текущей строке (r)
            # Примечание: triangle[r] имеет длину r+1, поэтому c идет от 0 до r.
            for c in range(r + 1):
                # 3. Расчет минимального пути:
                # Минимальный путь до текущей ячейки (r, c) - это ее собственное значение
                # плюс минимальное из двух значений в memo, которые соответствуют
                # ячейкам в строке ниже, в которые можно перейти из (r, c).
                # Из (r, c) можно перейти в (r+1, c) или (r+1, c+1).
                # Эти значения уже хранятся в memo[c] и memo[c+1] из предыдущей итерации.
                memo[c] = min(memo[c], memo[c+1]) + triangle[r][c]

        # 4. Результат:
        # После всех итераций, memo[0] будет содержать минимальную сумму пути
        # от вершины (0,0) до какой-либо ячейки в последней строке,
        # так как мы накапливали суммы снизу вверх.
        return memo[0]
```
#### Объяснение шагов ДП:

1. **`memo = triangle[row-1].copy()`**: Мы начинаем с того, что `memo` (сокращение от "memoization", т.е. запоминание результатов) хранит минимальные суммы путей до каждой ячейки _последней_ строки. Конечно, для ячейки в последней строке минимальный путь до нее самой равен ее собственному значению, если начать от нее.
    
2. **`for r in range(row - 2, -1, -1):`**: Мы идем по строкам снизу вверх, начиная с предпоследней строки.
    
3. **`for c in range(r + 1):`**: Для каждой ячейки `(r, c)` в текущей строке `r`.
    
4. **`memo[c] = min(memo[c], memo[c+1]) + triangle[r][c]`**:
    
    - Представь, что ты находишься в ячейке `(r, c)`.
    - Из нее ты можешь спуститься в `(r+1, c)` или `(r+1, c+1)`.
    - **Важный момент ДП:** Поскольку мы идем снизу вверх, когда мы находимся на строке `r`, мы _уже вычислили_ минимальные суммы пути от _нижней части треугольника_ до каждой ячейки на строке `r+1`.
    - Эти минимальные суммы для `(r+1, c)` и `(r+1, c+1)` фактически хранятся в `memo[c]` и `memo[c+1]` соответственно (потому что мы их перезаписывали на предыдущих итерациях).
    - Значит, минимальный путь, проходящий через `(r, c)` до самого низа треугольника, будет равен `triangle[r][c]` (значение текущей ячейки) плюс **минимум** из `memo[c]` (путь через левого потомка) и `memo[c+1]` (путь через правого потомка).
    - Мы обновляем `memo[c]` этим новым минимальным значением. Теперь `memo[c]` представляет минимальный путь от `(r, c)` до самого низа.
5. **`return memo[0]`**: Когда цикл завершится, `memo[0]` будет содержать минимальный путь от ячейки `(0,0)` (верхняя вершина треугольника) до самой нижней части, потому что все вычисления "схлопнулись" до этой одной ячейки.



**То есть, мы на каждой итерации решаем задачу найди наименьшее расстояние двух соседей**

