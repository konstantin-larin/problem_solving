---
tags:
  - problem
level: easy
---

Дата: [[29-06-2025]]

# Ссылка: 
https://coderun.yandex.ru/seasons/2025-summer/tracks/common/problem/stairs

# Понимание условия
 - Ограничения по времени/памяти
 - Диапазоны входных данных
 - Разбери все случаи, включая крайние, которые будет решать код

# Подход
- Что первым приходит в голову?
- Есть какие-то шаблоны?
- Есть ли возможность декомпозиции на частные случаи или на более простые задачи?

Самое первое, что пришло в голову это просматривать левого и правого соседа по условиям.
Но я понял, что это не сработает.
Идея: можно запоминать наименьшее пройденное число и наибольшее, чтоб при обращении текущего числа ориентироваться на это. Не уверен пока.
Примеры:

5 1 -1 -2 3 6
5:
1 меньше, что можно с ним сделать?
ничего. только обратить 5 можно. 
То есть на самом деле обход соседей может не такая уж пропащая идея, как минимум потому, что на итерации действительно мы можем сделать лишь несколько действий. Единственная загвоздка, что если действий множество, а не одно, то мы можем выбрать неправильное. Например, если бы вместо 1 стояло бы число -6. Тут уже два действия: обратить 5 в -5 И обратить -6 в 6. Надо понять, когда надо делать первое, а когда второе дейтсвие. 
Также непонятно, менять ли расклад, если el < next_el?
1 2 1
1 < 2 - окей идем дальше
2 < 1? нет, что можно сделать? только обратить 2 в минус 2
но тогда 1 > -2.
....
идея: доступно 2 варианта числа  -x и x. Есть минимальный порог - предыдущее значение, которое один из вариантов должен превзойти (быть больше). Если подходят оба варианта, мы просто выбираем наименьший из них.
То есть это самый правильный способ построить массив по возрастанию, имея возможность только инвертировать знак.
# Код
```python
def solution(n: int, m: int, p: list[int]) -> list[int]:        

    # lower_bound будет хранить минимально допустимое значение для res_p[i]

    # upper_bound будет хранить максимально допустимое значение для res_p[i]

  

    # Заполняем lower_bound проходом слева направо

    lower_bound = [0] * n

    # Инициализация первого элемента

    if p[0] != -1:

        if p[0] < m: # Если первый раунд меньше минимального заработка

            return [-1]

        lower_bound[0] = p[0]

    else:

        lower_bound[0] = m # Минимальный возможный заработок за первый раунд

  

    for i in range(1, n):

        if p[i] != -1:

            # Если значение p[i] известно, оно должно быть не меньше p[i-1] + m

            if p[i] < lower_bound[i-1] + m:

                return [-1]

            lower_bound[i] = p[i]

        else:

            # Если p[i] неизвестно, его минимальное значение - это p[i-1] + m

            lower_bound[i] = lower_bound[i-1] + m

  

    # Заполняем upper_bound проходом справа налево

  

    #    Убеждаемся, что каждое значение не превышает p[i+1] - m

    upper_bound = [0] * n

  

    # Инициализация последнего элемента

    if p[n-1] != -1:

        upper_bound[n-1] = p[n-1]

    else:

        '''

        Если последний элемент неизвестен, ему нет верхнего ограничения от последующих

        Но ему есть ограничение от предыдущих: он должен быть не меньше lower_bound[n-1]                        

        '''        

        upper_bound[n-1] = lower_bound[n-1]

  
  

    for i in range(n - 2, -1, -1):

        if p[i] != -1:

            # Если p[i] известно, оно должно быть не больше p[i+1] - m

            if p[i] > upper_bound[i+1] - m:

                return [-1]

            upper_bound[i] = p[i]

        else:

            # Если p[i] неизвестно, его максимальное значение - это p[i+1] - m

            upper_bound[i] = upper_bound[i+1] - m

        # upper_bound[i] также не может быть меньше lower_bound[i]

        # Если границы пересеклись, решение невозможно

        if upper_bound[i] < lower_bound[i]:

            return [-1]

  

    '''

    Восстанавливаем res_p с учетом обеих границ

    Если p[i] == -1, мы можем выбрать любое значение между lower_bound[i] и upper_bound[i].        

    Для восстановления используем upper_bound как окончательный массив, так как он

    уже скорректирован сверху, и если -1 были, они заполнены максимальным возможным значением

    при условии выполнения p[i] <= p[i+1] - m.        

    '''          

    res_p = [0] * n

    res_p[n-1] = upper_bound[n-1] # Последний элемент определяется upper_bound

  

    for i in range(n - 2, -1, -1):

        if p[i] != -1:

            res_p[i] = p[i]

        else:            

            res_p[i] = res_p[i+1] - m                                                            

  
  

    # после восстановления надо только посчитать разницу между res_p[i] и res_p[i + 1],

    # отталкиваясь от первого элемента

    ans = [0] * n

    ans[0] = res_p[0]

    for i in range(1, n):

        ans[i] = res_p[i] - res_p[i - 1]

  

    return ans
```
# Ревью

Жадно решил задачу, рассмотрев граничные условия.