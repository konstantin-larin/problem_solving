---
tags:
  - problem
level: medium
---

Дата: [[27-06-2025]]

# Ссылка: 
https://coderun.yandex.ru/seasons/2025-summer/tracks/common/problem/commotion-in-the-guard

# Понимание условия
 - Ограничения по времени/памяти
 - Диапазоны входных данных
 - Разбери все случаи, включая крайние, которые будет решать код

# Подход
- Что первым приходит в голову?
- Есть какие-то шаблоны?
- Есть ли возможность декомпозиции на частные случаи или на более простые задачи?
- Достаточно ли знаний алгоритмов и структур данных, чтобы решить эту задачу? Если нет - изучаем, если да - можно запускать таймер

Просто пройтись циклом и проверить кучу условий. Естественно, память огромным массивом из единиц и нулей засорять не будем (+ это еще считать затратно каждую итерацию сколько единиц на слайсе от 0 до n - 1)
# Код
```python
def solution(n, m, swaps):

    result = [0] * m

    d = dict() # здесь будем запоминать свапнутые места и кто в них находится

  

    # методы находятся от 1 до n

    # your code

    # текущее количество методов на позициях от 1 до n

    methods = n

    for i in range(m):

        j = swaps[2 * i] # место 1

        z = swaps[2 * i + 1] # место 2

        # происходит обмен местами гвардейцев        

        # для начала нужно понять кто на этих местах стоит сейчас

        # 1 будет методом

        # 0 будет функцией

        on_j = None

        on_z = None

        # проверяем для обоих

        # если место не записано в словаре, значит оно не было тронуто

        # значит на нем стоит по умолчанию либо метод (от 1 до n) либо функция (от n + 1 до 2n)

  

        # кто стоит на j?

        if j in d:

            on_j = d[j]

        else:

            on_j = 1 if j <= n else 0

        # кто стоит на z?

        if z in d:

            on_z = d[z]

        else:

            on_z = 1 if z <= n else 0

        # фиксируем изменение в словаре

        d[j] = on_z

        d[z] = on_j

  

        # после того как мы определились, кто стоит на этих местах мы должны затронуть множество стоящих

        # на позициях от 1 до n, проверив, не затрагивает ли их изменение и если затрагивает, то как

  

        if (j <= n and z <= n )or (z > n and j > n):

            # нам неважно кого с кем поменяли, так как методов на местах от 1 до n такое же количество

            # главное, что ранее были зафиксированы изменения

            result[i] = methods    

            continue        

  

        #  в этих случаях мы меняем места из двух разных частей

        if on_j == 1 and on_z == 1:

            result[i] = methods

            # поменяли метод на метод - ничего страшного

            continue

        if on_j == 0 and on_z == 0:

            result[i] = methods

            # количество также не поменялось

            continue

  

        if j <= n:

            # значит z > n

            if on_j == 1 and on_z == 0:

                # поменяли метод на функцию, методов стало меньше                                

                methods -= 1            

            else:

                # наоборот поменяли функцию на метод, методов стало на 1 больше

                methods += 1

        else:

            # j > n, z <= n

            if on_j == 0 and on_z == 1:

                methods -= 1

                # убежал метод на другую часть

            else:

                methods += 1

        result[i] = methods                

    return result
```
# Ревью

